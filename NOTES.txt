


08:16:18.618006 IP 10.73.230.7 > 10.73.230.6: GREv0, length 84: IP6 ::.58506 > fd6e:eec8:76ac:1337::1.80: Flags [S], seq 3650118250, win 64800, options [mss 1440,sackOK,TS val 2977051604 ecr 0,nop,wscale 7], length 0

08:17:56.479577 IP 10.73.230.7 > 10.73.230.6: GREv0, length 84: IP6 ::.43522 > fd6e:eec8:76ac:1337::1.80: Flags [S], seq 1150346349, win 64800, options [mss 1440,sackOK,TS val 2977149442 ecr 0,nop,wscale 7], length 0


08:18:05.836414 IP 10.73.230.7 > 10.73.230.6: GREv0, length 84: IP6 fd6e:eec8:76ac:ac1d:100::1.44412 > fd6e:eec8:76ac:1337::1.80: Flags [S], seq 1967986794, win 64800, options [mss 1440,sackOK,TS val 3100324130 ecr 0,nop,wscale 7], length 0



// all backends in data plane have full source IP/HW addresses in destinfo - no need to look up seperate VLAN details
// On a single inferface then TX always
// On a single/bond interface with VLAN header then update VLAN header (if necc) and TX always
// On multiple interfaces with a single VLAN then TX always (bond)
// On multiple interfaces then REDIRECT always

// https://developers.redhat.com/blog/2019/05/17/an-introduction-to-linux-virtual-interfaces-tunnels

https://www.etb-tech.com/netronome-agilio-cx-40gb-qsfp-dual-port-low-profile-network-card-pcbd0097-005-nic00476.html

https://datatracker.ietf.org/doc/html/draft-herbert-gue-01

bpf_printk: cat /sys/kernel/debug/tracing/trace_pipe

# remember to set up IPv6 and VIPs
ip a add 192.168.101.201 dev lo
ip -6 a add fd6e:eec8:76ac:ac1d:200::1 dev lo

* check VIP against known list
* lookup flow in state table first
* if not there then try shared flow table
* if not found then lookup backend server/tunnel info
* modify packet
* if required then store new/updated flow record in state table
* push to userland queue if necessary
* update stats
* TX/redirect_map packet as indicated in dest record



**********************************************************************

# can use same port for IP and IPV6 in GOU as there is a protocol field

# IPv4 in GUE4
modprobe fou
modprobe ipip
ip fou add port 9999 gue
ip link set dev tunl0 up
sysctl -w net.ipv4.conf.tunl0.rp_filter=0
sysctl -w net.ipv4.conf.all.rp_filter=0

# IPv6 in GUE4
modprobe fou
modprobe sit
ip l set dev sit0 up
ip fou add port 9999 gue

**********************************************************************

# IPv4 in FOU4
modprobe fou
modprobe ipip
ip fou add port 9999 ipproto 4
ip link set dev tunl0 up
sysctl -w net.ipv4.conf.tunl0.rp_filter=0
sysctl -w net.ipv4.conf.all.rp_filter=0

# IPv6 in FOU4
modprobe fou
modprobe sit
ip l set dev sit0 up
ip fou add port 6666 ipproto 41

# IPv6 in FOU6
modprobe fou
modprobe fou6 # creates ip6tnl0
ip -6 fou add port 6666 ipproto 41
ip l set dev ip6tnl0 up
# DOES NOT WORK ATM - I thought this was working previously

# IPv4 in FOU6 - couldn't get to work

**********************************************************************

# IPIP
modprobe ipip
ip l set dev tunl0 up
tcpdump tunl0
sysctl -w net.ipv4.conf.tunl0.rp_filter=0
sysctl -w net.ipv4.conf.all.rp_filter=0

# 6in4
modprobe sit
ip l set dev sit0 up

# 6in6
modprobe ip6_tunnel
ip -6 tunnel change ip6tnl0 mode ip6ip6
ip l set dev ip6tnl0 up

# 4in6 
modprobe ip6_tunnel
ip -6 tunnel change ip6tnl0 mode ip4ip6
ip l set dev ip6tnl0 up
sysctl -w net.ipv4.conf.ip6tnl0.rp_filter=0
sysctl -w net.ipv4.conf.all.rp_filter=0

**********************************************************************

# 4in4 and 6in4 4 GRE
modprobe ip_gre
ip l set dev gre0 up
sysctl -w net.ipv4.conf.gre0.rp_filter=0
sysctl -w net.ipv4.conf.all.rp_filter=0

# 6in6 and 4in6 GRE
modprobe ip6_gre
ip l set dev ip6gre0 up
sysctl -w net.ipv4.conf.ip6gre0.rp_filter=0
sysctl -w net.ipv4.conf.all.rp_filter=0

**********************************************************************

ip link add name geneve0 type geneve id VNI remote REMOTE_IPv4_ADDR

ip link add name geneve0 type geneve id 666 remote 0.0.0.0
ip l set dev geneve0 up
sysctl -w net.ipv4.conf.geneve0.rp_filter=0
sysctl -w net.ipv4.conf.all.rp_filter=0

For a basic FOU4 backend:

/etc/networkd-dispatcher/routable.d/50-ifup-hooks:
#!/bin/sh
ip fou add port 9999 ipproto 4
ip link set dev tunl0 up
sysctl -w net.ipv4.conf.tunl0.rp_filter=0
sysctl -w net.ipv4.conf.all.rp_filter=0

/etc/modules:
fou
ipip


// magic code from https://mejedi.dev/posts/ebpf-dereference-of-modified-ctx-ptr-disallowed/
static __always_inline void *xdp_data_end(const struct xdp_md *ctx) {
    //return (void *)(long)ctx->data_end;
    void *data_end;
    
    asm("%[res] = *(u32 *)(%[base] + %[offset])"
	: [res]"=r"(data_end)
	: [base]"r"(ctx), [offset]"i"(offsetof(struct xdp_md, data_end)), "m"(*ctx));
    
    return data_end;
}









static __always_inline
__u16 new_internet_checksum(void *data, void *data_end, __u32 csum)
{
    __u16 *p = data;

    for (int n = 0; n < 128; n += 2) {
        if (p + 1 > data_end)
            break;
        csum += *p;
        p++;
    }

    if (((void *) p) + 1 <= data_end) {
        csum += *((__u8 *) p);
    }

    return csum_fold_helper(csum);
}


#define CHUNK 128
#define MULTI 12
// 128 * 12 = 1536 (greater than MTU)

__u8 BLANK[CHUNK] = {};


__u16 internet_checksum(void *data, void *data_end, __u32 csum)
{
    struct chunk {
        __u8 foo[CHUNK];
    };

    if (data_end - data > (CHUNK*MULTI))
        return 0;

    for (int n = 0; n < MULTI; n++, data += CHUNK) {
        unsigned int left = data_end - data;

        if (left >= CHUNK) {
            struct chunk *chunk = data;

            if (chunk + 1 > data_end)
                return 0;

            csum = bpf_csum_diff((__be32 *)BLANK, sizeof(*chunk), (__be32 *)chunk, sizeof(*chunk), csum);
        } else {
            return new_internet_checksum(data, data_end, left);
        }
    }

    return csum_fold_helper(csum);
}



    /*
    if (0) {
	addr_t saddr = {};
	__u8 h_source[6];
	__u8 h_gw[6];
	
	// migrate to using per-VLAN details for the tunnel source params - why?
	// oh, yeah, to allow failover from one LB to another rather than store LB local params
	// don't need to do this - just need this unless copying session from shared table
	// useful to test here though
	if (is_ipv4_addr_p(&(t->daddr))) {
	    saddr.addr4.addr = vlan->ip4;
	    memcpy(h_source, vlan->hw4, 6);
	    memcpy(h_gw, vlan->gh4, 6);
	} else {
	    saddr = vlan->ip6;
	    memcpy(h_source, vlan->hw6, 6);
	    memcpy(h_gw, vlan->gh6, 6);
	}
	
	t->saddr = saddr;
	memcpy(t->h_source, h_source, 6);
	
	if ((t->method != T_NONE) && (t->flags & F_NOT_LOCAL)) {
	    bpf_printk("F_NOT_LOCAL\n");
	    memcpy(t->h_dest, h_gw, 6); // send packet to router
	}
    }
    */
